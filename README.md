# Chat-Pyton3-WS-Kafka-Redis-MySql-Docker
![Image alt](https://github.com/MaximRobota/Chat-Pyton3-WS-Kafka-Redis-MySql-Docker-/blob/master/task.png)

* Client uses a Websocket to connect to 'websocket service'
* Client can register with a login and password using identity service
* Any service can get user id by using identity service

### Identity service:
```
/register (name, pass) -> token
/auth (name, pass) -> token
/getIdByToken -> int (id)
```
### Web socket service
* Uses kafka to post messages that need saving (queue “message_save”)
* Listens to kafka (queue “message_events”)
* Checks that a user is a valid user (id service) and only then posts the message to “message_save”
* Sends updates about messages to correct users
* If a user with an invalid token sends a message ignore it and log a warning to stdout

### Message persistence service
* Listens on “message_save” queue
* Saves messages to database and rollback if an error occurs:
* In case of an error log error to stdout 
* Send a message error to “message_events”
* In case of message is saved send message id and other data to “message_events”

### Redis
* Redis can be used as a key-value storage by websocket service:
	* Save user id and message UUID (provided by the client)
	* Is required to keep track on which messages are sent by which users

### Client
* Connect to a websocket 
* Sends message text, user_to_id and a random UUID (generated by client)
* The message UUID is used to identify the message until the message is actually allotted a database id
 (until it is saved)

1. Client sends:
```
{ 
	uuid: “a62f2bf7-cfe7-48d6x-ad53-956e41b0769b”,
	Message: “hi”,
	user_to : 2
}
```
*With jwt_token in headers (at connection time)*

1. Websocket service:
	1. Marks the message UUID as the one sent by a user with some id  (1? - get the id by token).

	1. When a message is saved Websocket service gets a message on “message_events” queue : 
	``` 
	{
		uuid: “a62f2bf7-cfe7-48d6x-ad53-956e41b0769b”,
		state: “Saved”
	}
	```
1. Websocket service looks up the corresponding websocket handle to send the event (saved)to the correct user and sends 
	```
	{
		uuid: “a62f2bf7-cfe7-48d6x-ad53-956e41b0769b”,
		state: “Saved”
	}
	```
1. Client gets the message and can identify the correct message to mark it as “successfully sent”.



General:
* Every service is a docker container.
* Every service is written in python 3 (3.7 +)
* Use docker-compose to run the whole stack
* Expect every service to run on the same host (localhost)
* Every service runs on some port
* This port is defined as an environment variable (ENV_VAR)
* Docker-compose.yaml should define the ports for each service  (do not hardcode the port values, use environment variables only) 

Example:
```
import os 
os.environ[“KAFKA_PORT”] / os.environ[“ID_SERVICE_PORT”]/ ...


web_socket_service:
	Image:
Build: ..

Environment:
	KAFKA_PORT: 5050
persistence_service:
	Image:
Build: ..

Environment:
	KAFKA_PORT: 5050 
```
### Acceptance criteria
* Docker-compose -f docker_compose.yaml up
* Python3 client_test.py 
* Registers 2 users,
* User 1 sends a message to user 2 
* assert ( wait for 20 secs) that the message is saved 
* Message uuid matches the one we created
* Message state is “saved”


### Plan
- [ ] Hello world with redis 
- [ ] Save and get values (remove value too)
- [ ] Hello world with kafka
- [ ] 2 processes 
	1. sends a message
	2. prints the received message
- [ ] Figure out what is python flask 
- [ ] Flask app for identity service  
- [ ] Create schema for database
- [ ] Create docker image for identity service 
- [ ] Create docker image for database
- [ ] Create docker-compose.yaml for id_service and database 
- [ ] Use docker-compose up to start the two services

### QUICK START (Use for help 'command.txt')

```
sudo docker-compose build
```

```
sudo docker-compose up
```
Services: http://localhost:5051 (:5052, :5053)

DB (adminer): http://localhost:8080
